// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

float3      _LightPosition;
float3      _CameraPosition;
float4x4    _CameraToWorld;
float4x4    _CameraInverseProjection;
float       _NumRaysPerPixel;
uint        _IterationCount;

struct Material
{
    float4 color;       //16 byte
    float smoothness;   //4  byte
    float3 padding;     //12 byte
};

struct Sphere
{
    float3 position;    //12 byte
    float radius;       //4  byte
    
    Material material;  //32 byte
};

struct Ray
{
    float3 origin;
    float3 direction;
};

struct HitInfo
{
    bool isHit;
    float distance;
    float3 position;
    float3 normal;
    Material material;
};

StructuredBuffer<Sphere> _Spheres;

uint numSpheres;
uint sphereStride = 48;
float width, height;

float RandomUInt(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return ((word >> 22u) ^ word) / 4294967295.0;
}

HitInfo SphereRayIntersect(Ray ray, Sphere sphere)
{   
    HitInfo hitInfo = (HitInfo)0;
    float3 offsetRayOrigin = ray.origin - sphere.position;
    
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(offsetRayOrigin, ray.direction);
    float c = dot(offsetRayOrigin, offsetRayOrigin) - sphere.radius * sphere.radius;
    
    float d = b * b - 4 * a * c;
    
    if (d >= 0)
    {
        float distance = (-b - sqrt(d)) / (2 * a);
        
        if (distance >= 0)
        {
            hitInfo.isHit = true;
            hitInfo.distance = distance;
            hitInfo.position = ray.origin + ray.direction * distance;
            hitInfo.normal = normalize(hitInfo.position - sphere.position);
            hitInfo.material = sphere.material;
        }
    }
    
    return hitInfo;
}

HitInfo FindClosestSphereIntersection(Ray ray)
{
    HitInfo closestHit = (HitInfo) 0;
    
    closestHit.distance = 1.#INF;
    
    for (uint i = 0; i < numSpheres; i++)
    {
        Sphere sphere = _Spheres[i];
        
        HitInfo hitInfo = SphereRayIntersect(ray, sphere);

        if (hitInfo.isHit && hitInfo.distance < closestHit.distance)
        {
            closestHit = hitInfo;
            closestHit.material = hitInfo.material;
        }
    }

    return closestHit;
}

Ray ConstructPixelRay(uint3 id, uint index)
{
    uint pixelID = id.x * width + id.y;
    float random = RandomUInt(pixelID + _IterationCount + index);
    
    Ray ray;
    ray.origin = _CameraPosition;
    
    float2 uv = (id.xy + float2(random.xx)) / float2(width, height) * 2.0 - 1.0;
    
    float4 clipUV = float4(uv, 0, 1);
    float4 rayView = mul(_CameraInverseProjection, clipUV);
    rayView /= rayView.w;
    
    float3 rayDirection = normalize(mul(_CameraToWorld, float4(rayView.xyz, 0)).xyz);
    
    ray.direction = rayDirection;
    
    return ray;
}

float3 Trace(Ray ray)
{
    //Find the closest intersection with a sphere
    HitInfo closestIntersection = FindClosestSphereIntersection(ray);
    
    //Get the color of the sphere and store it for later use
    float4 finalColor = closestIntersection.material.color;
    
    //Create a ray from the closest intersection to the light source to get simple shadows
    Ray hitPointRay;
    hitPointRay.origin = closestIntersection.position + closestIntersection.normal * 0.001;
    hitPointRay.direction = normalize(_LightPosition - hitPointRay.origin);
    
    //Check if the constructed ray intersects anything on its way to the light source, if it is dim the color
    if (FindClosestSphereIntersection(hitPointRay).isHit)
    {
        finalColor *= 0.2;
    }
    
    return finalColor;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //Cache some useful values for later use
    Result.GetDimensions(width, height);
    _Spheres.GetDimensions(numSpheres, sphereStride);
    
    float3 finalColor;
    
    //Create multiple rays per pixel with slight variations
    for (uint i = 0; i < _NumRaysPerPixel; i++)
    {
        Ray ray = ConstructPixelRay(id, i);
        finalColor += Trace(ray);
    }
    
    //Output the color to the pixel
    Result[id.xy] = float4(finalColor / _NumRaysPerPixel, 1);
    
    //uint pixelID = id.y * width + id.x;
    //float final = RandomUInt(pixelID);
    //Result[id.xy] = float4(final.xxx, 1);
}
